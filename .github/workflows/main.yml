name: build-kernelsu-next-susfs

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      REPO: 0xSoul24/kernel_google_msm-4.14
      KERNEL_DIR: ${{ github.workspace }}/kernel
      SCRIPTS_DIR: ${{ github.workspace }}/scripts
      OUTDIR: ${{ github.workspace }}/out
      NDK_VERSION: "r25c"

    steps:
      - name: Checkout repository (LFS enabled)
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Install dependencies
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            git bc bison flex libssl-dev libncurses5-dev libelf-dev \
            device-tree-compiler python3 python3-pip unzip curl file \
            pkg-config build-essential abootimg

      - name: Download Android NDK
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$HOME/android-ndk"
          NDK_TAR="android-ndk-${NDK_VERSION}-linux.zip"
          curl -sS -L "https://dl.google.com/android/repository/${NDK_TAR}" -o "${NDK_TAR}"
          unzip -q "${NDK_TAR}" -d "$HOME/android-ndk"
          echo "$(ls -d $HOME/android-ndk/android-ndk-*)" > "$HOME/ndk_root"

      - name: Setup NDK env
        shell: bash
        run: |
          set -euo pipefail
          export NDKROOT="$(cat "$HOME/ndk_root")"
          echo "NDKROOT=$NDKROOT" >> "$GITHUB_ENV"
          echo "$NDKROOT/toolchains/llvm/prebuilt/linux-x86_64/bin" >> "$GITHUB_PATH"

      - name: Checkout kernel source
        uses: actions/checkout@v4
        with:
          repository: ${{ env.REPO }}
          path: kernel
          fetch-depth: 0

      - name: Get KernelSU-next and SUSFS modules
        shell: bash
        run: |
          set -euo pipefail
          git clone --depth=1 https://github.com/tiann/KernelSU.git kernelsu-next || true
          git clone --depth=1 https://github.com/sidex15/susfs4ksu-module.git susfs4ksu-module || true
          ls -la kernelsu-next susfs4ksu-module || true

      - name: Prepare workspace
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$OUTDIR"
          ls -la

      - name: Make scripts executable
        shell: bash
        run: |
          set -euo pipefail
          chmod +x "$SCRIPTS_DIR"/*.py "$SCRIPTS_DIR"/*.sh || true
          ls -la "$SCRIPTS_DIR" || true

      - name: Obtain stock boot image (repo-root only)
        id: getboot
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$OUTDIR"

          if [ -f "$GITHUB_WORKSPACE/boot.img" ]; then
            echo "Using boot.img from repository root"
            cp "$GITHUB_WORKSPACE/boot.img" "$OUTDIR/boot.img"
          else
            echo "ERROR: boot.img not found at repository root: $GITHUB_WORKSPACE/boot.img" >&2
            exit 3
          fi

          echo "Verifying boot image..."
          file "$OUTDIR/boot.img" || true
          # Guard against an accidental text/HTML file
          if head -c 16 "$OUTDIR/boot.img" | strings | head -n1 | grep -qi '<!'; then
            echo "File looks like HTML (not a boot image). Ensure boot.img is a valid binary." >&2
            exit 4
          fi

      - name: Unpack boot image
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$OUTDIR/unpacked"
          python3 "$SCRIPTS_DIR/unpack_bootimg.py" --input "$OUTDIR/boot.img" --outdir "$OUTDIR/unpacked"
          ls -la "$OUTDIR/unpacked" || true

      - name: Extract kernel config (best-effort)
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "$KERNEL_DIR/scripts/extract-ikconfig" ]; then
            "$KERNEL_DIR/scripts/extract-ikconfig" "$OUTDIR/unpacked/"* > "$OUTDIR/.config" || true
          else
            python3 "$SCRIPTS_DIR/extract_ikconfig.py" "$OUTDIR/unpacked/"* > "$OUTDIR/.config" || true
          fi
          if [ ! -s "$OUTDIR/.config" ]; then
            echo "No IKCONFIG found; falling back to device defconfig if present"
            if [ -f "$KERNEL_DIR/arch/arm64/configs/flame_defconfig" ]; then
              cp "$KERNEL_DIR/arch/arm64/configs/flame_defconfig" "$OUTDIR/.config"
            elif [ -f "$KERNEL_DIR/arch/arm64/configs/flame-perf_defconfig" ]; then
              cp "$KERNEL_DIR/arch/arm64/configs/flame-perf_defconfig" "$OUTDIR/.config"
            else
              echo "# fallback minimal config" > "$OUTDIR/.config"
            fi
          fi
          echo "Config stored at $OUTDIR/.config"

      - name: Apply KernelSU-next patches (best-effort)
        shell: bash
        run: |
          set -euo pipefail
          cd "$KERNEL_DIR"
          if [ -d "${{ github.workspace }}/kernelsu-next/patches" ]; then
            echo "Applying KernelSU patches from kernelsu-next/patches..."
            for p in "${{ github.workspace }}"/kernelsu-next/patches/*.patch; do
              [ -e "$p" ] || continue
              echo "Applying $p"
              git apply --reject --whitespace=fix "$p"
            done
          else
            echo "kernelsu-next/patches not found; skipping KernelSU patch application"
          fi

      - name: Build kernel
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -d "$NDKROOT" ]; then
            echo "ERROR: NDKROOT does not exist: $NDKROOT" >&2
            exit 5
          fi

          export PATH="$NDKROOT/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH"
          export ARCH=arm64
          export SUBARCH=arm64
          export CC=clang
          export LLVM=1
          export LLVM_IAS=1
          export CROSS_COMPILE=aarch64-linux-android-
          export CROSS_COMPILE_ARM32=arm-linux-androideabi-

          KOUT="$OUTDIR/kernel_out"
          mkdir -p "$KOUT"

          # Choose a defconfig
          if [ -f "$KERNEL_DIR/arch/arm64/configs/flame_defconfig" ]; then
            DEFCONFIG="flame_defconfig"
          elif [ -f "$KERNEL_DIR/arch/arm64/configs/flame-perf_defconfig" ]; then
            DEFCONFIG="flame-perf_defconfig"
          else
            DEFCONFIG=""
            echo "WARNING: flame(_perf)_defconfig not found; attempting olddefconfig with extracted .config"
          fi

          pushd "$KERNEL_DIR" >/dev/null
          if [ -n "$DEFCONFIG" ]; then
            make O="$KOUT" ARCH=arm64 "$DEFCONFIG" -j"$(nproc)"
          else
            cp "$OUTDIR/.config" "$KOUT/.config" || true
            make O="$KOUT" ARCH=arm64 olddefconfig -j"$(nproc)" || true
          fi

          make O="$KOUT" ARCH=arm64 -j"$(nproc)"
          popd >/dev/null

          # Locate built kernel image
          KERNEL_IMG=""
          if [ -f "$KOUT/arch/arm64/boot/Image.gz-dtb" ]; then
            KERNEL_IMG="$KOUT/arch/arm64/boot/Image.gz-dtb"
          elif [ -f "$KOUT/arch/arm64/boot/Image.lz4-dtb" ]; then
            KERNEL_IMG="$KOUT/arch/arm64/boot/Image.lz4-dtb"
          elif [ -f "$KOUT/arch/arm64/boot/Image" ]; then
            KERNEL_IMG="$KOUT/arch/arm64/boot/Image"
          fi

          if [ -z "$KERNEL_IMG" ]; then
            echo "ERROR: Built kernel image not found in $KOUT/arch/arm64/boot" >&2
            ls -la "$KOUT/arch/arm64/boot" || true
            exit 6
          fi

          echo "KERNEL_IMG=$KERNEL_IMG" >> "$GITHUB_ENV"
          echo "Using built kernel image: $KERNEL_IMG"

      - name: Repack boot image with new kernel
        shell: bash
        run: |
          set -euo pipefail
          PATCHED_BOOT="$OUTDIR/boot_patched.img"
          bash "$SCRIPTS_DIR/repack_boot.sh" --orig "$OUTDIR/boot.img" --kernel "$KERNEL_IMG" --out "$PATCHED_BOOT"
          ls -la "$PATCHED_BOOT" || true

      - name: Upload patched boot image
        uses: actions/upload-artifact@v4
        with:
          name: boot_patched.img
          path: ${{ env.OUTDIR }}/boot_patched.img
          if-no-files-found: error
