name: build-kernelsu-next-susfs

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      REPO: 0xSoul24/kernel_google_msm-4.14
      KERNEL_DIR: ${{ github.workspace }}/kernel
      OUTDIR: ${{ github.workspace }}/out
      NDK_VERSION: "r25c"

    steps:
      - name: Checkout repository (LFS enabled)
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Install build dependencies (incl. cross toolchains) and magiskboot
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            git bc bison flex libssl-dev libncurses5-dev libelf-dev \
            device-tree-compiler python3 python3-pip unzip curl file \
            pkg-config build-essential abootimg \
            gcc-aarch64-linux-gnu gcc-arm-linux-gnueabi lz4 cpio
          # Install magiskboot (for modern boot images, unpack/repack)
          sudo curl -sSL -o /usr/local/bin/magiskboot \
            https://github.com/topjohnwu/Magisk/releases/latest/download/magiskboot
          sudo chmod +x /usr/local/bin/magiskboot
          magiskboot --help >/dev/null || { echo "magiskboot not installed correctly"; exit 1; }

      - name: Download Android NDK
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$HOME/android-ndk"
          NDK_TAR="android-ndk-${NDK_VERSION}-linux.zip"
          curl -sS -L "https://dl.google.com/android/repository/${NDK_TAR}" -o "${NDK_TAR}"
          unzip -q "${NDK_TAR}" -d "$HOME/android-ndk"
          echo "$(ls -d $HOME/android-ndk/android-ndk-*)" > "$HOME/ndk_root"

      - name: Setup NDK env
        shell: bash
        run: |
          set -euo pipefail
          export NDKROOT="$(cat "$HOME/ndk_root")"
          echo "NDKROOT=$NDKROOT" >> "$GITHUB_ENV"
          echo "$NDKROOT/toolchains/llvm/prebuilt/linux-x86_64/bin" >> "$GITHUB_PATH"

      - name: Checkout kernel source
        uses: actions/checkout@v4
        with:
          repository: ${{ env.REPO }}
          path: kernel
          fetch-depth: 0

      - name: Get KernelSU-next and SUSFS modules
        shell: bash
        run: |
          set -euo pipefail
          git clone --depth=1 https://github.com/tiann/KernelSU.git kernelsu-next || true
          git clone --depth=1 https://github.com/sidex15/susfs4ksu-module.git susfs4ksu-module || true
          ls -la kernelsu-next susfs4ksu-module || true

      - name: Prepare workspace
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$OUTDIR"
          ls -la

      - name: Obtain stock boot image (repo-root only)
        id: getboot
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$OUTDIR"

          if [ -f "$GITHUB_WORKSPACE/boot.img" ]; then
            echo "Using boot.img from repository root"
            cp "$GITHUB_WORKSPACE/boot.img" "$OUTDIR/boot.img"
          else
            echo "ERROR: boot.img not found at repository root: $GITHUB_WORKSPACE/boot.img" >&2
            exit 3
          fi

          echo "Verifying boot image..."
          file "$OUTDIR/boot.img" || true
          # Guard against an accidental text/HTML file
          if head -c 16 "$OUTDIR/boot.img" | strings | head -n1 | grep -qi '<!'; then
            echo "File looks like HTML (not a boot image). Ensure boot.img is a valid binary." >&2
            exit 4
          fi

      - name: Unpack boot image (magiskboot first, abootimg fallback)
        shell: bash
        run: |
          set -euo pipefail
          UNP="$OUTDIR/unpacked"
          rm -rf "$UNP"; mkdir -p "$UNP"
          # Try magiskboot (modern header v3+)
          if magiskboot unpack "$OUTDIR/boot.img" -o "$UNP" >/dev/null 2>&1; then
            echo "Unpacked with magiskboot into $UNP"
          else
            echo "magiskboot unpack failed, trying abootimg..."
            pushd "$UNP" >/dev/null
            if abootimg -x "$OUTDIR/boot.img"; then
              echo "Unpacked with abootimg into $UNP"
            else
              echo "ERROR: Failed to unpack boot image with magiskboot and abootimg" >&2
              exit 7
            fi
            popd >/dev/null
          fi
          ls -la "$UNP" || true

      - name: Apply KernelSU-next patches (best-effort)
        shell: bash
        run: |
          set -euo pipefail
          cd "$KERNEL_DIR"
          if [ -d "${{ github.workspace }}/kernelsu-next/patches" ]; then
            echo "Applying KernelSU patches from kernelsu-next/patches..."
            for p in "${{ github.workspace }}"/kernelsu-next/patches/*.patch; do
              [ -e "$p" ] || continue
              echo "Applying $p"
              git apply --reject --whitespace=fix "$p"
            done
          else
            echo "kernelsu-next/patches not found; skipping KernelSU patch application"
          fi

      - name: Build kernel (fix CLANG_TRIPLE error)
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -d "$NDKROOT" ]; then
            echo "ERROR: NDKROOT does not exist: $NDKROOT" >&2
            exit 5
          fi

          export PATH="$NDKROOT/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH"
          export ARCH=arm64
          export SUBARCH=arm64
          export CC=clang
          export LLVM=1
          export LLVM_IAS=1
          # Android Clang detected by kernel -> provide GNU binutils triple
          export CLANG_TRIPLE=aarch64-linux-gnu-
          # Android NDK cross prefixes
          export CROSS_COMPILE=aarch64-linux-android-
          export CROSS_COMPILE_ARM32=arm-linux-androideabi-
          # Provide compat GNU triple so Makefile is happy when needed
          export CROSS_COMPILE_COMPAT=arm-linux-gnueabi-

          KOUT="$OUTDIR/kernel_out"
          mkdir -p "$KOUT"

          # Choose a defconfig
          if [ -f "$KERNEL_DIR/arch/arm64/configs/flame_defconfig" ]; then
            DEFCONFIG="flame_defconfig"
          elif [ -f "$KERNEL_DIR/arch/arm64/configs/flame-perf_defconfig" ]; then
            DEFCONFIG="flame-perf_defconfig"
          elif [ -f "$KERNEL_DIR/arch/arm64/configs/defconfig" ]; then
            DEFCONFIG="defconfig"
          else
            DEFCONFIG=""
            echo "WARNING: flame(_perf)_defconfig not found; using generic defconfig"
          fi

          pushd "$KERNEL_DIR" >/dev/null
          if [ -n "$DEFCONFIG" ]; then
            make O="$KOUT" ARCH=arm64 "$DEFCONFIG" -j"$(nproc)"
          else
            make O="$KOUT" ARCH=arm64 defconfig -j"$(nproc)"
          fi

          make O="$KOUT" ARCH=arm64 -j"$(nproc)"
          popd >/dev/null

          # Locate built kernel image
          KERNEL_IMG=""
          if [ -f "$KOUT/arch/arm64/boot/Image.gz-dtb" ]; then
            KERNEL_IMG="$KOUT/arch/arm64/boot/Image.gz-dtb"
          elif [ -f "$KOUT/arch/arm64/boot/Image.lz4-dtb" ]; then
            KERNEL_IMG="$KOUT/arch/arm64/boot/Image.lz4-dtb"
          elif [ -f "$KOUT/arch/arm64/boot/Image" ]; then
            KERNEL_IMG="$KOUT/arch/arm64/boot/Image"
          fi

          if [ -z "$KERNEL_IMG" ]; then
            echo "ERROR: Built kernel image not found in $KOUT/arch/arm64/boot" >&2
            ls -la "$KOUT/arch/arm64/boot" || true
            exit 6
          fi

          echo "KERNEL_IMG=$KERNEL_IMG" >> "$GITHUB_ENV"
          echo "Using built kernel image: $KERNEL_IMG"

      - name: Repack boot image with new kernel (magiskboot first, abootimg fallback)
        shell: bash
        run: |
          set -euo pipefail
          PATCHED_BOOT="$OUTDIR/boot_patched.img"
          TMP=$(mktemp -d)
          cleanup() { rm -rf "$TMP"; }
          trap cleanup EXIT

          # Try magiskboot repack (modern)
          if magiskboot unpack "$OUTDIR/boot.img" -o "$TMP" >/dev/null 2>&1; then
            cp -f "$KERNEL_IMG" "$TMP/kernel"
            if magiskboot repack "$OUTDIR/boot.img" -o "$TMP/new-boot.img" >/dev/null 2>&1 && [ -f "$TMP/new-boot.img" ]; then
              mv -f "$TMP/new-boot.img" "$PATCHED_BOOT"
              echo "Repacked with magiskboot: $PATCHED_BOOT"
            else
              echo "magiskboot repack failed, trying abootimg..." >&2
              # Fallback to abootimg
              rm -rf "$TMP"; mkdir -p "$TMP"; pushd "$TMP" >/dev/null
              if abootimg -x "$OUTDIR/boot.img"; then
                RAMDISK=""
                for r in initrd.img ramdisk.img ramdisk.cpio.gz initramfs.cpio.gz; do
                  [ -f "$r" ] && RAMDISK="$r" && break
                done
                if [ -f bootimg.cfg ] && [ -n "$RAMDISK" ]; then
                  abootimg --create "$PATCHED_BOOT" -f bootimg.cfg -k "$KERNEL_IMG" -r "$RAMDISK"
                  echo "Repacked with abootimg: $PATCHED_BOOT"
                else
                  echo "ERROR: abootimg fallback failed to find ramdisk/cfg" >&2
                  exit 8
                fi
              else
                echo "ERROR: abootimg fallback failed to unpack original image" >&2
                exit 9
              fi
              popd >/dev/null
            fi
          else
            echo "magiskboot unpack failed; attempting abootimg direct repack..." >&2
            pushd "$TMP" >/dev/null
            if abootimg -x "$OUTDIR/boot.img"; then
              RAMDISK=""
              for r in initrd.img ramdisk.img ramdisk.cpio.gz initramfs.cpio.gz; do
                [ -f "$r" ] && RAMDISK="$r" && break
              done
              if [ -f bootimg.cfg ] && [ -n "$RAMDISK" ]; then
                abootimg --create "$PATCHED_BOOT" -f bootimg.cfg -k "$KERNEL_IMG" -r "$RAMDISK"
                echo "Repacked with abootimg: $PATCHED_BOOT"
              else
                echo "ERROR: abootimg fallback failed to find ramdisk/cfg" >&2
                exit 8
              fi
            else
              echo "ERROR: Could not repack boot image with magiskboot or abootimg" >&2
              exit 5
            fi
            popd >/dev/null
          fi

          ls -la "$PATCHED_BOOT" || true

      - name: Upload patched boot image
        uses: actions/upload-artifact@v4
        with:
          name: boot_patched.img
          path: ${{ env.OUTDIR }}/boot_patched.img
          if-no-files-found: error
